package tools

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	"github.com/temporalio/cloud-samples-go/cmd/mcp-server/clients"
	"github.com/temporalio/cloud-samples-go/cmd/mcp-server/config"
	"github.com/temporalio/cloud-samples-go/workflows"
	"go.temporal.io/cloud-sdk/api/cloudservice/v1"
	"go.temporal.io/cloud-sdk/api/identity/v1"
)

// RegisterUserTools registers all user management tools with the MCP server
func RegisterUserTools(mcpServer *server.MCPServer, cfg *config.Config, clientManager *clients.ClientManager) {
	// Register temporal_get_user tool
	mcpServer.AddTool(
		mcp.NewTool("temporal_get_user",
			mcp.WithDescription("Get a Temporal Cloud user by ID"),
			mcp.WithString("user_id", mcp.Description("User ID"), mcp.Required()),
		),
		func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return handleGetUser(ctx, request, clientManager)
		},
	)

	// Register temporal_list_users tool
	mcpServer.AddTool(
		mcp.NewTool("temporal_list_users",
			mcp.WithDescription("List Temporal Cloud users with pagination"),
			mcp.WithNumber("page_size", mcp.Description("Number of users per page (optional)")),
			mcp.WithString("next_page_token", mcp.Description("Token for next page (optional)")),
		),
		func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return handleListUsers(ctx, request, clientManager)
		},
	)

	// Register temporal_find_user_by_email tool
	mcpServer.AddTool(
		mcp.NewTool("temporal_find_user_by_email",
			mcp.WithDescription("Find a Temporal Cloud user by email address"),
			mcp.WithString("email", mcp.Description("User email address"), mcp.Required()),
		),
		func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return handleFindUserByEmail(ctx, request, clientManager)
		},
	)

	// Register temporal_create_user tool
	mcpServer.AddTool(
		mcp.NewTool("temporal_create_user",
			mcp.WithDescription("Create a new Temporal Cloud user"),
			mcp.WithObject("user_spec", mcp.Description("User specification object"), mcp.Required()),
		),
		func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return handleCreateUser(ctx, request, clientManager)
		},
	)

	// Register temporal_update_user tool
	mcpServer.AddTool(
		mcp.NewTool("temporal_update_user",
			mcp.WithDescription("Update an existing Temporal Cloud user"),
			mcp.WithString("user_id", mcp.Description("User ID"), mcp.Required()),
			mcp.WithObject("user_updates", mcp.Description("User updates object"), mcp.Required()),
		),
		func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return handleUpdateUser(ctx, request, clientManager)
		},
	)

	// Register temporal_delete_user tool
	mcpServer.AddTool(
		mcp.NewTool("temporal_delete_user",
			mcp.WithDescription("Delete a Temporal Cloud user"),
			mcp.WithString("user_id", mcp.Description("User ID"), mcp.Required()),
		),
		func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return handleDeleteUser(ctx, request, clientManager)
		},
	)

	// Register temporal_reconcile_users tool
	mcpServer.AddTool(
		mcp.NewTool("temporal_reconcile_users",
			mcp.WithDescription("Bulk reconcile multiple users with optional cleanup"),
			mcp.WithArray("users_spec", mcp.Description("Array of user specifications"), mcp.Required()),
			mcp.WithBoolean("delete_unspecified", mcp.Description("Delete users not in specification (optional)")),
		),
		func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			return handleReconcileUsers(ctx, request, clientManager)
		},
	)
}

// Tool handler functions

func handleGetUser(ctx context.Context, request mcp.CallToolRequest, clientManager *clients.ClientManager) (*mcp.CallToolResult, error) {
	// Extract user_id from request arguments
	arguments := request.GetArguments()
	userID, ok := arguments["user_id"].(string)
	if !ok || userID == "" {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: "Error: user_id is required and must be a string",
			}},
		}, nil
	}

	// Call GetUser activity directly through cloud client
	cloudClient := clientManager.GetCloudClient()
	getUserReq := &cloudservice.GetUserRequest{
		UserId: userID,
	}

	user, err := cloudClient.CloudService().GetUser(ctx, getUserReq)
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error getting user: %v", err),
			}},
		}, nil
	}

	// Convert result to JSON
	resultJSON, err := json.MarshalIndent(user.User, "", "  ")
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error serializing result: %v", err),
			}},
		}, nil
	}

	return &mcp.CallToolResult{
		Content: []mcp.TextContent{{
			Type: "text",
			Text: string(resultJSON),
		}},
	}, nil
}

func handleListUsers(ctx context.Context, request mcp.CallToolRequest, clientManager *clients.ClientManager) (*mcp.CallToolResult, error) {
	arguments := request.GetArguments()
	
	// Extract optional pagination parameters
	var pageSize int32 = 50 // default
	if ps, ok := arguments["page_size"].(float64); ok {
		pageSize = int32(ps)
	}
	
	nextPageToken := ""
	if token, ok := arguments["next_page_token"].(string); ok {
		nextPageToken = token
	}

	// Call GetUsers through cloud client
	cloudClient := clientManager.GetCloudClient()
	getUsersReq := &cloudservice.GetUsersRequest{
		PageSize:      pageSize,
		NextPageToken: nextPageToken,
	}

	result, err := cloudClient.CloudService().GetUsers(ctx, getUsersReq)
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error listing users: %v", err),
			}},
		}, nil
	}

	resultJSON, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error serializing result: %v", err),
			}},
		}, nil
	}

	return &mcp.CallToolResult{
		Content: []mcp.TextContent{{
			Type: "text",
			Text: string(resultJSON),
		}},
	}, nil
}

func handleGetAllUsers(ctx context.Context, request mcp.CallToolRequest, clientManager *clients.ClientManager) (*mcp.CallToolResult, error) {
	// Use the existing GetAllUsers workflow
	result, err := clientManager.ExecuteWorkflow(ctx, workflows.GetAllUsersWorkflowType, nil)
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error getting all users: %v", err),
			}},
		}, nil
	}

	resultJSON, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error serializing result: %v", err),
			}},
		}, nil
	}

	return &mcp.CallToolResult{
		Content: []mcp.TextContent{{
			Type: "text",
			Text: string(resultJSON),
		}},
	}, nil
}

func handleFindUserByEmail(ctx context.Context, request mcp.CallToolRequest, clientManager *clients.ClientManager) (*mcp.CallToolResult, error) {
	arguments := request.GetArguments()
	email, ok := arguments["email"].(string)
	if !ok || email == "" {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: "Error: email is required and must be a string",
			}},
		}, nil
	}

	// Use the existing GetUserWithEmail workflow
	result, err := clientManager.ExecuteWorkflow(ctx, workflows.GetUserWithEmailWorkflow, email)
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error finding user by email: %v", err),
			}},
		}, nil
	}

	resultJSON, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error serializing result: %v", err),
			}},
		}, nil
	}

	return &mcp.CallToolResult{
		Content: []mcp.TextContent{{
			Type: "text",
			Text: string(resultJSON),
		}},
	}, nil
}

func handleCreateUser(ctx context.Context, request mcp.CallToolRequest, clientManager *clients.ClientManager) (*mcp.CallToolResult, error) {
	arguments := request.GetArguments()
	userSpecRaw, ok := arguments["user_spec"]
	if !ok {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: "Error: user_spec is required",
			}},
		}, nil
	}

	// Convert user_spec to proper type
	userSpecJSON, err := json.Marshal(userSpecRaw)
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error parsing user_spec: %v", err),
			}},
		}, nil
	}

	var userSpec identity.UserSpec
	if err := json.Unmarshal(userSpecJSON, &userSpec); err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error parsing user specification: %v", err),
			}},
		}, nil
	}

	// Use the existing CreateUser workflow
	result, err := clientManager.ExecuteWorkflow(ctx, workflows.CreateUserWorkflowType, &userSpec)
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error creating user: %v", err),
			}},
		}, nil
	}

	resultJSON, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error serializing result: %v", err),
			}},
		}, nil
	}

	return &mcp.CallToolResult{
		Content: []mcp.TextContent{{
			Type: "text",
			Text: string(resultJSON),
		}},
	}, nil
}

func handleUpdateUser(ctx context.Context, request mcp.CallToolRequest, clientManager *clients.ClientManager) (*mcp.CallToolResult, error) {
	arguments := request.GetArguments()
	userID, ok := arguments["user_id"].(string)
	if !ok || userID == "" {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: "Error: user_id is required and must be a string",
			}},
		}, nil
	}

	userUpdatesRaw, ok := arguments["user_updates"]
	if !ok {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: "Error: user_updates is required",
			}},
		}, nil
	}

	// Convert to proper update request
	updatesJSON, err := json.Marshal(userUpdatesRaw)
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error parsing user_updates: %v", err),
			}},
		}, nil
	}

	var updateReq cloudservice.UpdateUserRequest
	if err := json.Unmarshal(updatesJSON, &updateReq); err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error parsing user updates: %v", err),
			}},
		}, nil
	}
	updateReq.UserId = userID

	// Use the existing UpdateUser workflow
	result, err := clientManager.ExecuteWorkflow(ctx, workflows.UpdateUserWorkflowType, &updateReq)
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error updating user: %v", err),
			}},
		}, nil
	}

	resultJSON, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error serializing result: %v", err),
			}},
		}, nil
	}

	return &mcp.CallToolResult{
		Content: []mcp.TextContent{{
			Type: "text",
			Text: string(resultJSON),
		}},
	}, nil
}

func handleDeleteUser(ctx context.Context, request mcp.CallToolRequest, clientManager *clients.ClientManager) (*mcp.CallToolResult, error) {
	arguments := request.GetArguments()
	userID, ok := arguments["user_id"].(string)
	if !ok || userID == "" {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: "Error: user_id is required and must be a string",
			}},
		}, nil
	}

	// Use the existing DeleteUser workflow
	deleteReq := &cloudservice.DeleteUserRequest{
		UserId: userID,
	}

	result, err := clientManager.ExecuteWorkflow(ctx, workflows.DeleteUserWorkflowType, deleteReq)
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error deleting user: %v", err),
			}},
		}, nil
	}

	resultJSON, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error serializing result: %v", err),
			}},
		}, nil
	}

	return &mcp.CallToolResult{
		Content: []mcp.TextContent{{
			Type: "text",
			Text: string(resultJSON),
		}},
	}, nil
}

func handleReconcileUsers(ctx context.Context, request mcp.CallToolRequest, clientManager *clients.ClientManager) (*mcp.CallToolResult, error) {
	arguments := request.GetArguments()
	usersSpecRaw, ok := arguments["users_spec"]
	if !ok {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: "Error: users_spec is required",
			}},
		}, nil
	}

	deleteUnspecified := false
	if del, ok := arguments["delete_unspecified"].(bool); ok {
		deleteUnspecified = del
	}

	// Convert users specification
	usersJSON, err := json.Marshal(usersSpecRaw)
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error parsing users_spec: %v", err),
			}},
		}, nil
	}

	var usersInput workflows.ReconcileUsersInput
	if err := json.Unmarshal(usersJSON, &usersInput.Users); err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error parsing users specification: %v", err),
			}},
		}, nil
	}
	usersInput.DeleteUnspecified = deleteUnspecified

	// Use the existing ReconcileUsers workflow
	result, err := clientManager.ExecuteWorkflow(ctx, workflows.ReconcileUsersWorkflowType, &usersInput)
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error reconciling users: %v", err),
			}},
		}, nil
	}

	resultJSON, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.TextContent{{
				Type: "text",
				Text: fmt.Sprintf("Error serializing result: %v", err),
			}},
		}, nil
	}

	return &mcp.CallToolResult{
		Content: []mcp.TextContent{{
			Type: "text",
			Text: string(resultJSON),
		}},
	}, nil
}